<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Creative Surge - Minimal Single File</title>
  <style>
    /* Force page and body to fill the entire screen and be black */
    html, body {
      margin: 0; 
      padding: 0; 
      width: 100%; 
      height: 100%;
      background: #000; 
      overflow: hidden;
      font-family: Arial, sans-serif;
    }
    /* Container that holds the canvas, score, and overlay */
    #gameContainer {
      position: absolute; 
      top: 0; 
      left: 0;
      width: 100%; 
      height: 100%;
      background: #000;
    }
    /* The 3D canvas fills #gameContainer */
    #gameCanvas {
      position: absolute;
      top: 0; 
      left: 0;
      width: 100%;
      height: 100%;
      display: block;
    }
    /* Score in top-left, large white text, above the canvas */
    #score {
      position: absolute;
      top: 10px; 
      left: 10px;
      z-index: 999;
      font-size: 24px;
      font-weight: bold;
      color: #fff;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
    }
    /* Semi-transparent overlay for start and game-over states */
    #overlay {
      position: absolute;
      top: 0; 
      left: 0;
      width: 100%; 
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      display: flex; 
      align-items: center; 
      justify-content: center;
      z-index: 1000;
    }
    /* Text in the centre of the overlay */
    #overlayText {
      font-size: 32px;
      text-align: center;
      white-space: pre-line;
      color: #fff;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
      line-height: 1.4;
      max-width: 80%;
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas"></canvas>
    <!-- Scoreboard at top-left -->
    <div id="score">Score: 0</div>
    <!-- Overlay for start/game-over messages -->
    <div id="overlay">
      <div id="overlayText">
Welcome to Creative Surge!

Press Spacebar to Start

Instructions:
- Use Left/Right arrows or A/D to move
- Use Up arrow or W to jump
- Collect yellow orbs for bonus points
- Avoid red obstacles and holes in the road

Your High Score: 0
      </div>
    </div>
  </div>

  <!-- Three.js library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
  /***********************************************
   * Minimal Creative Surge Code with Jump & Holes
   ***********************************************/
  let scene, camera, renderer;
  let player, targetX;
  let obstacles = [];
  let orbs = [];
  let holes = [];
  let score = 0;
  let gameSpeed = 0.1;
  let lastTime = performance.now();
  let obstacleTimer = 1500;
  let orbTimer = 3000;
  let holeTimer = 5000;  // Hole spawn timer (milliseconds)
  let gameState = "start";  // "start", "playing", or "gameover"

  const baseObstacleInterval = 1500;
  const baseOrbInterval = 3000;
  const baseHoleInterval = 5000;

  // Jump physics variables
  let isJumping = false;
  let jumpVelocity = 0;
  const gravity = -20;

  // Local high score
  let localHighScore = Number(localStorage.getItem("highscore")) || 0;

  // Returns a custom collision box for obstacles (based on player's feet)
  function getPlayerCollisionBox() {
    const halfWidth = 1.25;
    const boxHeight = 0.4;
    const halfDepth = 2;
    const baseY = player.position.y - 0.5;
    const min = new THREE.Vector3(player.position.x - halfWidth, baseY, player.position.z - halfDepth);
    const max = new THREE.Vector3(player.position.x + halfWidth, baseY + boxHeight, player.position.z + halfDepth);
    return new THREE.Box3(min, max);
  }

  function init() {
    scene = new THREE.Scene();

    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 5, 20);

    const canvas = document.getElementById("gameCanvas");
    renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);

    // Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(0, 50, 50);
    scene.add(directionalLight);

    // Ground plane
    const groundGeo = new THREE.PlaneGeometry(20, 1000);
    const groundMat = new THREE.MeshBasicMaterial({ color: 0x111111 });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.position.z = -490;
    scene.add(ground);

    // --- Player: "Futuristic Racer" design ---
    const playerGroup = new THREE.Group();

    // Main body: a streamlined green box
    const bodyGeo = new THREE.BoxGeometry(2.5, 1, 4);
    const bodyMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
    const body = new THREE.Mesh(bodyGeo, bodyMat);
    body.position.set(0, 0, 0);
    playerGroup.add(body);

    // Cockpit: a blue sphere positioned on top of the body
    const cockpitGeo = new THREE.SphereGeometry(0.75, 16, 16);
    const cockpitMat = new THREE.MeshBasicMaterial({ color: 0x0000ff });
    const cockpit = new THREE.Mesh(cockpitGeo, cockpitMat);
    cockpit.position.set(0, 0.75, -0.5);
    playerGroup.add(cockpit);

    // Left fin: a thin red box for aerodynamic effect
    const leftFinGeo = new THREE.BoxGeometry(0.1, 0.5, 1);
    const finMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
    const leftFin = new THREE.Mesh(leftFinGeo, finMat);
    leftFin.position.set(-1.35, 0, 0.5);
    playerGroup.add(leftFin);

    // Right fin: a mirrored version of the left fin
    const rightFinGeo = new THREE.BoxGeometry(0.1, 0.5, 1);
    const rightFin = new THREE.Mesh(rightFinGeo, finMat);
    rightFin.position.set(1.35, 0, 0.5);
    playerGroup.add(rightFin);

    // Rear fin: an additional fin at the back
    const rearFinGeo = new THREE.BoxGeometry(0.5, 0.1, 1);
    const rearFin = new THREE.Mesh(rearFinGeo, finMat);
    rearFin.position.set(0, 0.5, 2);
    playerGroup.add(rearFin);

    // Position the player and add to the scene
    playerGroup.position.set(0, 0, 10);
    scene.add(playerGroup);
    player = playerGroup;
    targetX = player.position.x;
    // --- End of Player Design ---

    // Key listener
    document.addEventListener("keydown", onKeyDown);

    // Update overlay text
    if (gameState === "start") {
      const overlayText = document.getElementById("overlayText");
      overlayText.innerText = 
        `Welcome to Creative Surge!\n\n` +
        `Press Spacebar to Start\n\n` +
        `Instructions:\n` +
        `- Use Left/Right arrows or A/D to move\n` +
        `- Use Up arrow or W to jump\n` +
        `- Collect yellow orbs for bonus points\n` +
        `- Avoid red obstacles and holes in the road\n\n` +
        `Your High Score: ${localHighScore}`;
    }

    animate();
  }

  function onKeyDown(e) {
    const overlay = document.getElementById("overlay");
    const overlayText = document.getElementById("overlayText");

    if (gameState === "start") {
      if (e.key === " ") {
        gameState = "playing";
        overlay.style.display = "none";
      }
    } else if (gameState === "playing") {
      // Increase step size for more responsive movement
      const step = 2;
      if (e.key === "ArrowLeft" || e.key === "a") {
        targetX = Math.max(targetX - step, -8);
      } else if (e.key === "ArrowRight" || e.key === "d") {
        targetX = Math.min(targetX + step, 8);
      } else if (e.key === "ArrowUp" || e.key === "w") {
        if (!isJumping) {
          isJumping = true;
          jumpVelocity = 12;
        }
      }
    } else if (gameState === "gameover") {
      if (e.key === " ") {
        restartGame();
        overlay.style.display = "none";
      }
    }
  }

  function generateObstacle() {
    const geo = new THREE.BoxGeometry(1, 1, 1);
    const mat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
    const obs = new THREE.Mesh(geo, mat);
    obs.position.x = (Math.random() - 0.5) * 16;
    obs.position.y = 0.5;
    obs.position.z = player.position.z - 50;
    obs.rotation.x = Math.random() * Math.PI;
    obs.rotation.y = Math.random() * Math.PI;
    obs.userData.type = "obstacle";
    scene.add(obs);
    obstacles.push(obs);
  }

  function generateOrb() {
    const geo = new THREE.SphereGeometry(0.5, 16, 16);
    const mat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
    const orb = new THREE.Mesh(geo, mat);
    orb.position.x = (Math.random() - 0.5) * 16;
    orb.position.y = 0.5;
    orb.position.z = player.position.z - 70;
    orb.userData.type = "orb";
    scene.add(orb);
    orbs.push(orb);
  }

  function generateHole() {
    const holeWidth = Math.random() * 2 + 2;
    const holeDepth = Math.random() * 1 + 2;
    const holeGeo = new THREE.BoxGeometry(holeWidth, 0.1, holeDepth);
    const holeMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
    const hole = new THREE.Mesh(holeGeo, holeMat);
    hole.position.x = (Math.random() - 0.5) * 16;
    hole.position.y = 0.05;
    hole.position.z = player.position.z - 60;
    hole.userData = { width: holeWidth, depth: holeDepth };
    scene.add(hole);
    holes.push(hole);
  }

  function checkCollisions(obj) {
    if (obj.userData.type === "obstacle") {
      const playerBox = getPlayerCollisionBox();
      const objBox = new THREE.Box3().setFromObject(obj);
      return playerBox.intersectsBox(objBox);
    } else {
      const playerBox = new THREE.Box3().setFromObject(player);
      const objBox = new THREE.Box3().setFromObject(obj);
      return playerBox.intersectsBox(objBox);
    }
  }

  function triggerGameOver() {
    gameState = "gameover";
    if (Math.floor(score) > localHighScore) {
      localHighScore = Math.floor(score);
      localStorage.setItem("highscore", localHighScore);
    }
    const overlay = document.getElementById("overlay");
    const overlayText = document.getElementById("overlayText");
    overlayText.innerText = 
      `GAME OVER\n` +
      `Final Score: ${Math.floor(score)}\n` +
      `High Score: ${localHighScore}\n\n` +
      `Press Spacebar to Restart`;
    overlay.style.display = "flex";
  }

  function restartGame() {
    gameState = "playing";
    score = 0;
    gameSpeed = 0.1;
    isJumping = false;
    jumpVelocity = 0;

    obstacles.forEach(obs => scene.remove(obs));
    obstacles = [];
    orbs.forEach(orb => scene.remove(orb));
    orbs = [];
    holes.forEach(hole => scene.remove(hole));
    holes = [];

    player.position.set(0, 0, 10);
    targetX = player.position.x;

    lastTime = performance.now();
    obstacleTimer = baseObstacleInterval;
    orbTimer = baseOrbInterval;
    holeTimer = baseHoleInterval;
  }

  function animate() {
    requestAnimationFrame(animate);
    const currentTime = performance.now();
    const deltaTime = currentTime - lastTime;
    lastTime = currentTime;

    if (gameState === "playing") {
      score += gameSpeed * (deltaTime / 16.67);
      document.getElementById("score").innerText = "Score: " + Math.floor(score);

      if (isJumping) {
        const dt = deltaTime / 1000;
        jumpVelocity += gravity * dt;
        player.position.y += jumpVelocity * dt;
        if (player.position.y <= 0) {
          player.position.y = 0;
          isJumping = false;
          jumpVelocity = 0;
        }
      }

      // Increased smoothing factor for horizontal movement
      player.position.x += (targetX - player.position.x) * 0.2;
      // Slightly faster camera follow for a smoother feel
      camera.position.x += (player.position.x - camera.position.x) * 0.1;

      for (let i = obstacles.length - 1; i >= 0; i--) {
        const obs = obstacles[i];
        obs.position.z += gameSpeed * (deltaTime / 16.67);
        obs.rotation.x += 0.01 * (deltaTime / 16.67);
        obs.rotation.y += 0.01 * (deltaTime / 16.67);
        if (obs.position.z > camera.position.z + 10) {
          scene.remove(obs);
          obstacles.splice(i, 1);
        } else if (checkCollisions(obs)) {
          triggerGameOver();
        }
      }

      for (let i = orbs.length - 1; i >= 0; i--) {
        const orb = orbs[i];
        orb.position.z += gameSpeed * (deltaTime / 16.67);
        orb.rotation.y += 0.02 * (deltaTime / 16.67);
        if (orb.position.z > camera.position.z + 10) {
          scene.remove(orb);
          orbs.splice(i, 1);
        } else if (checkCollisions(orb)) {
          score += 50;
          scene.remove(orb);
          orbs.splice(i, 1);
        }
      }

      for (let i = holes.length - 1; i >= 0; i--) {
        const hole = holes[i];
        hole.position.z += gameSpeed * (deltaTime / 16.67);
        if (hole.position.z > camera.position.z + 10) {
          scene.remove(hole);
          holes.splice(i, 1);
        } else {
          const halfWidth = hole.userData.width / 2;
          const halfDepth = hole.userData.depth / 2;
          if (player.position.y <= 0.1 &&
              player.position.x >= hole.position.x - halfWidth &&
              player.position.x <= hole.position.x + halfWidth &&
              player.position.z >= hole.position.z - halfDepth &&
              player.position.z <= hole.position.z + halfDepth) {
            triggerGameOver();
          }
        }
      }

      obstacleTimer -= deltaTime;
      orbTimer -= deltaTime;
      holeTimer -= deltaTime;
      if (obstacleTimer <= 0) {
        generateObstacle();
        obstacleTimer = Math.max(500, baseObstacleInterval - Math.floor(score / 10));
      }
      if (orbTimer <= 0) {
        generateOrb();
        orbTimer = Math.max(1000, baseOrbInterval - Math.floor(score / 20));
      }
      if (holeTimer <= 0) {
        generateHole();
        holeTimer = baseHoleInterval;
      }

      gameSpeed += 0.0001 * deltaTime;
    }

    renderer.render(scene, camera);
  }

  window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  init();
  </script>
</body>
</html>
